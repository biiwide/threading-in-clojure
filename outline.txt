Goals:I. Why multithreaded programming is worth learning about, and the difference between parallelism and concurrency.II. Why multithreaded is worth learning in Clojure.III. Several design patterns for multithreaded programs, and how Clojure as a technology lowers thebarrier of entry through more accessible techniques. Doing this helps you better leverage your computer.I.Multithreaded programming is a way for us to write more preformat applications but providing simultaneous execution of programs.  Some examples include handling connection requests or collecting and digesting big data.Machines are very powerful, but they are not becoming a powerful as quickly as they used to. CPU clock speeds have barely increased in recent years and there are more dual core and quad core computers which means in order to make a program near twice as fast, you have to divide up work between the two cores.Concurrency refers to managing more than one job at the same time, whereas Parallelism is executing two jobs at the same time.II.Learning how to write multithreaded programs is hard. In the JRuby community there are four rules you need to follow before writing them:"In general, the safest path to concurrency in JRuby is the same as on any other platform:1.Don't do it.2.If you must do it, don't share data across threads.3.If you must share data across threads, don't share mutable data.4.If you must share mutable data across threads, synchronize access to that data."3 and 4 talk about something called mutable data.  Mutable data is dangerous between threads because if you have more than one thread reading and changing data, it can potentially put it in an inconsistent state that causes something called RACE CONDITIONS.Race conditions occur when you run your multithreaded program and you consistently get difference results.  Clojure inherently allows us to protect ourselves from this right off the bat.  We'll see more proof for this later.III.i. How multithreaded programming usually goes...Lets walk through our list of why the community generally advises you to not to use threadingas your first choice for solving a problem. In particular, lets see why you shouldn't share mutable dataacross threads.We're going to use the example of a bank account. We'll be going out of our way to use Java APIs, which means this is not a typical Clojure approach to this problem.Bank accounts have a running balance that should never drop below $0. You can query the balance at a certain point in time, withdraw money from it, and make deposits.The first way we're going to use concurrnecy is with futures.~~~Futures - allow you to shove off work into another thread.~~~```1 (defprotocol IAccount2   (balance [this])3   (withdraw [this val])4   (deposit [this val]))5 (deftype Account [^:volatile-mutable checking]6   IAccount7   (balance [this] (. this checking))8   (withdraw [this val] ( if (<= val checking)9                             (set! checking (- checking val))10                            (print "Insufficient funds!\n")))11  (deposit [this val] (set! checking (+ checking val))))12 (def a (Account. 5))```Above we have created an account data type that keeps track of a checking account balance. You can query the balance, and make deposits and withdrawals.If we run:> (balance a)We get 5, or essentially $5.> (deposit 10)We get $15.> (withdraw 10)We get $5 again.Lets create 10 different threads that all try to withdraw $1 from our account at the same time. What will happen? The correct behavior is to make 5 successful withdrawals and be alerted about insufficient funds 5 times.```(doseq [i (range 10)]  (future ((withdraw a 1))))(balance a)```When thread 1 is checking if the value to be withdrawn is still less than the current balance in the checking account on line 8, it proceeds to line 9 to deduct the amount.However, in the time it takes for thread 1 to get from line 8 to line 9, thread 2 could have successfully withdrawn the last dollar!This is why it is bad to share our bank account's checking state in 10 different threads, and what is referred to as a race condition.  A race condition essentially meansthat your program has unexpected and inconssitent results each time it is executed.In most other languages there is a way to fix this issue. When thread 1 is checking is checking if it is valid to continue making the withdrawal, we can lock the account down until we're finished. When the account is locked,no other thread can read or write to it, and it slows down performace.  Which brings us to rule #4.~~~Blocking - Waiting for an operation to finish before continuing with your work.~~~~~~Async - When you continue with your program and handle additional jobs as they come up.~~~```(doseq [i (range 10)]  (future (locking a ((withdraw a 1)))))(balance a)```ii. Drinking the Clojure koolaid.One of CLojure's awesome features is immutability. Remember how #3 specifically advises you against sharing mutable state between threads?  Clojure makes it easy for you by offering you many different ways to completely avoid that pitfall we saw in the previous example.First we're going to talk about Atoms.~~~Atom: A datatype that is indivisible and unchanging. A process generates a new atom and we choose to associate the identity with the new atom.  Which keeps us from mutating the data.~~~``` (def a (atom {:checking 5})) (defn balance [] (:checking @a)) (defn withdraw [val] ( if (<= val (:checking @a) )                             (swap! a update-in [:checking] - val)                             (print "Insufficient funds!\n")))(doseq [i (range 10)] (future ((withdraw 1))))(balance)```Here is our first step toward changing what we have to begin using atoms.  We still have a problem. While we are using swap to safely change the identity of the checkingaccount balance between threads, we still check the validity of the operation outside of our threadsafe function.```(defn check-and-withdraw [account val] ( if (<= val (:checking account) )                                         (assoc account :checking (- (:checking account) val))                                         (do                                           (print "Insufficient funds!\n")                                           account)))(def a (atom {:checking 5}))(defn balance [] (:checking @a))(defn withdraw [val] (swap a check-and-withdraw val))(doseq [i (range 10)] (future ((withdraw 1))))(balance)```~~~Agent: Like an atom such that it will represent some state of an identity at some point in time, but can be asynchronous. For example you can keepsending work to an agent and carry on with your program.~~~```(def a (agent {:checking 100}))(defn withdraw [account val] ( if (<= val (:checking account) )                                    (assoc account :checking (- (:checking account) val))                                    (do                                      (print "Insufficient funds!\n")                                      account)))(defn balance [] (:checking @a))(send a withdraw 1)(balance)```